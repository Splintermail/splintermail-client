# http grammar
# rfc7230: http syntax

{{#include <libhttp/libhttp.h>

// steal %param buf via a macro
#define DSTR_OFF_ZERO(prev) dstr_off_zero(prev, buf, 0)

static bool parse_status_code(dstr_off_t off, int *code){
    derr_t e = E_OK;
    *code = parse_int_within(&e, off, 100, 599);
    CATCH(e, E_ANY){
        DROP_VAR(&e);
        return false;
    }
    return true;
}

static void trace_http_error(derr_t *E, dstr_off_t token){
    // skip if E was not provided
    if(!E) return;

    // longest DBG char is \xNN, or 4 chars, and we have two lines of len 80
    // 80 * 4 * 2 = 640
    DSTR_VAR(context, 1024);
    get_token_context(&context, token, 80);

    TRACE_ORIG(E, E_RESPONSE, "invalid http:\n%x", FD(&context));
}

// recorded error message is based on sem.loc, and is written to E
static void http_handle_error(
    http_parser_t *p,
    const dstr_t *buf,
    derr_t *E,
    http_token_e http_token,
    http_sem_t sem,
    const unsigned char *expected_mask,
    const char *loc_summary
){
    (void)p;
    (void)buf;
    (void)http_token;
    (void)expected_mask;
    (void)loc_summary;

    trace_http_error(E, sem.loc);
}

}}

%generator c;
%prefix http;

%param buf {const dstr_t *};
%param E {derr_t *};

%kwarg semloc_type dstr_off_t;
%kwarg span_fn dstr_off_extend;
%kwarg zero_loc_fn DSTR_OFF_ZERO;
%kwarg error_fn http_handle_error;

%type i {int};
%type status_line {http_status_line_t};
%type pair {http_pair_t};
%type size {size_t};

# Tokens
INVALID;
EOF;

# groups
ALPHA;
DIGIT;
OBS_TEXT;  # 8th bit is set

TAB;
LF;
CR;
SP;
BANG;
DQUOTE;
POUND;
DOLLAR;
PERCENT;
AMPERSAND;
SQUOTE;
LPAREN;
RPAREN;
ASTERISK;
PLUS;
COMMA;
DASH;
DOT;
SLASH;
COLON;
SEMI;
LANGLE;
EQ;
RANGLE;
QUESTION;
ARUBA;
LBRACKET;
BACKSLASH;
RBRACKET;
CARET;
UNDER;
BACKTICK;
LBRACE;
PIPE;
RBRACE;
TILDE;

# keyword tokens
HTTP;
CHUNKED;

%fallback ALPHA HTTP CHUNKED;

vchar =
# | LF
# | CR
| DIGIT
| ALPHA
# | OBS_TEXT
# | TAB
# | SP
| BANG
| DQUOTE
| POUND
| DOLLAR
| PERCENT
| AMPERSAND
| SQUOTE
| LPAREN
| RPAREN
| ASTERISK
| PLUS
| COMMA
| DASH
| DOT
| SLASH
| COLON
| SEMI
| LANGLE
| EQ
| RANGLE
| QUESTION
| ARUBA
| LBRACKET
| BACKSLASH
| RBRACKET
| CARET
| UNDER
| BACKTICK
| LBRACE
| PIPE
| RBRACE
| TILDE
;

tchar =
# | LF
# | CR
| DIGIT
| ALPHA
# | OBS_TEXT
# | TAB
# | SP
| BANG
# | DQUOTE
| POUND
| DOLLAR
| PERCENT
| AMPERSAND
| SQUOTE
# | LPAREN
# | RPAREN
| ASTERISK
| PLUS
# | COMMA
| DASH
| DOT
# | SLASH
# | COLON
# | SEMI
# | LANGLE
# | EQ
# | RANGLE
# | QUESTION
# | ARUBA
# | LBRACKET
# | BACKSLASH
# | RBRACKET
| CARET
| UNDER
| BACKTICK
# | LBRACE
| PIPE
# | RBRACE
| TILDE
;

qdtext =
# | LF
# | CR
# | DIGIT
# | ALPHA
# | OBS_TEXT
| TAB
| SP
| BANG
# | DQUOTE
| POUND
| DOLLAR
| PERCENT
| AMPERSAND
| SQUOTE
| LPAREN
| RPAREN
| ASTERISK
| PLUS
| COMMA
| DASH
| DOT
| SLASH
| COLON
| SEMI
| LANGLE
| EQ
| RANGLE
| QUESTION
| ARUBA
| LBRACKET
# | BACKSLASH
| RBRACKET
| CARET
| UNDER
| BACKTICK
| LBRACE
| PIPE
| RBRACE
| TILDE
;

ws = TAB|SP;
token = 1*tchar;

# at most one of {transfer-encoding:chunked, content-length} may be provided.
# rfc7230::3.3.3: Message Body Length (paraphrased):
#
# 1. HEAD response -> no body
#
# 2. 2xx response to a CONNECT implies the connection is a tunnel after header fields
#
# 3. If Transfer-Encoding is present and chunked transfer coding is the final encoding,
#    message body length is determined by reading and decoding data until the
#    transfer coding is indicates that data is complete.
#
#    If chunked transfer coding is not the final encoding, the message body
#    length is determined by reading the connection until it is closed by the
#    server.  Only servers may do this.
#
#    If content-length is also set, transfer-encoding overrides.  But probably
#    I'll just reject it as an error.
#
# 4. Multiple content-length fields with the same value are valid.  Invalid
#    content-length fields are invalid (duh).
#
# 5. If a valid content-length is present without transfer-encoding, use it.
#
# 6. If none of the above are true for a request, the length of the body is 0.
#
# 7. Otherwise, this is a response without a declared message length, so the
#    server just writes body bytes until it's done.
#
# The inclusion of close-delimited message is primarily for backwards-
# compatibility with HTTP/1.0, so probably we just won't allow it.

# Our strategy will be to parse headers line-by-line.

# note: we are choosing not to support obs-fold until we encounter a server
#       that we need to talk to which uses it.

%root status_line;
status_line:status_line =
    HTTP SLASH DIGIT DOT DIGIT SP status_code:s SP reason_phrase:r CR LF
    {{ $$ = (http_status_line_t){
           .code = $s,
           .reason = dstr_from_off(dstr_off_strip(@r, DSTR_LIT(" \t"))),
       };
    }}
;

status_code:i =
    DIGIT DIGIT DIGIT
    {{ if(!parse_status_code(@$, &$$)){
           trace_http_error(E, @$);
           return HTTP_STATUS_SYNTAX_ERROR;
       }
    }}
;
reason_phrase = *(ws | vchar | OBS_TEXT);

empty = %empty;

# note: hdr_line returns a zero-length key when it sees end-of-headers
%root hdr_line;
hdr_line:pair =
    (
      | token:name COLON *ws field_content_ws:field CR LF
        # a valid header
        {{ $$ = (http_pair_t){
               .key = dstr_from_off(@name),
               .value = dstr_from_off(dstr_off_strip(@field, DSTR_LIT(" \t"))),
           };
        }}
      | empty:e CR LF
        # end-of-headers
        {{ $$ = (http_pair_t){
               .key = dstr_from_off(@e),
               .value = dstr_from_off(@e),
           };
        }}
    )
;

field_vchar = vchar | OBS_TEXT;
field_content_ws = (vchar | OBS_TEXT) *(field_vchar|ws);

%root content_length_field;
content_length_field = 1*DIGIT EOF;

%root transfer_encoding_field;
transfer_encoding_field = transfer_codings_ws EOF;
transfer_codings_ws =
    *(COMMA *ws)
    1*(
        transfer_coding_ws
        (
          | 1*(COMMA *ws)
          | %return
        )
    )
;
# Note: we only support CHUNKED encoding; all others are treated as extensions.
transfer_coding_ws =
  | CHUNKED *ws
  | token *ws *(SEMI *ws transfer_parameter *ws)
;
transfer_parameter = token *ws EQ *ws (token | quoted_string);

quoted_string = DQUOTE *(qdtext | quoted_pair) DQUOTE;
quoted_pair = BACKSLASH (TAB | SP | vchar | OBS_TEXT);


%root chunk;
chunk:size = chunk_size:c *(SEMI chunked_extension) CR LF { $$ = $c; };

chunk_size:size = 1*(ALPHA | DIGIT)
 {{ dstr_t text = dstr_from_off(@$);
    derr_t e = dstr_tosize(&text, &$$, 16);
    CATCH(e, E_ANY){
        DROP_VAR(&e);
        trace_http_error(E, @$);
        return HTTP_STATUS_SYNTAX_ERROR;
    }
 }}
;

# rfc7230: "a recipient MUST ignore unrecognized chunk extensions" (we do)
chunked_extension = token [ EQ (token | quoted_string) ];
