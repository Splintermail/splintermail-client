# this file is the example grammar for testing the c and python generators
{{
    #include <stdio.h>

    typedef struct {
        size_t start;
        size_t end;
    } math_loc_t;

    math_loc_t math_span(math_loc_t loc, math_loc_t token_loc){
        return (math_loc_t){.start = loc.start, .end = token_loc.end};
    }
}}:c

%root line;
%root factor;

%generator c;
%kwarg:c prefix math;
%kwarg:c semloc_type math_loc_t;
%kwarg:c span_fn math_span;
%type:c i { int };

%kwarg:py prefix Math;

## You don't actually have to declare tokens, unless you want to set types.
# EOL;
NUM:i;
# PLUS;
# MINUS;
# MULT;
# DIV;
# LPAREN;
# RPAREN;

# Like sqlite's lemon.c parser generator, We support a %fallback directive.
# It is useful for allowing keywords in the grammar to additionally match as
# normal identfiers.  sqlite does it to allow identifiers which might conflict
# with obscure sql keywords.  Importantly, the fallback token type is only
# allowed in cases where the primary type would be a syntax error. In our math
# example, we'll have a couple 'keynumbers' which can also be normal numbers.
ZERO:i;
ONE:i;
%fallback NUM ZERO ONE;

# mult_op = MULT | DIV;
# sum_op = PLUS | MINUS;
# factor = NUM | LPAREN expr RPAREN;
# term = factor *(mult_op factor);
# expr = term *(sum_op term);
# line = < expr > EOL;

mult_op:i =
| MULT {$$=1;}
| DIV {$$=0;}
;

sum_op:i =
| PLUS {$$=1;}
| MINUS {$$=-1;}
;

factor:i =
| NUM:n {$$=$n;}
| LPAREN expr:e RPAREN {$$=$e;}
;

term:i =
    factor:f1 {$$=$f1;}
    *(
        mult_op:m
        factor:f2
        {$$=$$*$f2 if $m else $$/$f2}:py
        {$$=$m ? $$*$f2 : $$/$f2;}:c
    )
;

expr:i =
    term:t1 {$$=$t1;}
    *(
        sum_op:s
        term:t2
        {$$=$$ + $s*$t2;}
    )
;

line =
    <
        expr:e
        { $$ = $e; }:py
        { printf("line=%d\n", $e); }:c
    ?
        { print("bad line") }:py
        { printf("bad line\n"); }:c
    > EOL;

{{
    if __name__ == "__main__":
        tokens = [
            MathToken(PLUS),
            MathToken(EOL),

            MathToken(NUM, 18),
            MathToken(DIV),
            MathToken(NUM, 6),
            MathToken(DIV),
            MathToken(NUM, 3),
            MathToken(EOL),
        ]
        p = MathlineParser(repeat=True)
        for t in tokens:
            expr = p.feed(t)
            if expr is not None:
                print(expr.val)
}}:py

{{
    int main(int argc, char **argv){
        math_parser_t *p = math_parser_new(100, 100);
        if(!p) return 2;

        int tokens[] = {
            PLUS, 0,
            EOL, 0,

            NUM, 18,
            DIV, 0,
            NUM, 6,
            DIV, 0,
            NUM, 3,
            PLUS, 0,
            ZERO, 0,
            PLUS, 0,
            ONE, 1,
            EOL, 0,
        };
        size_t ntokens = sizeof(tokens) / sizeof(*tokens);

        for(size_t i = 0; i < ntokens; i += 2){
            // printf("feeding %s\n", math_token_name(tokens[i]));

            math_val_u val = { .i = tokens[i+1] };
            math_loc_t loc = {i, i+1};
            math_status_t status = math_parse_line(p, tokens[i], val, loc, NULL);
            if(status > MATH_STATUS_DONE){
                printf("got bad status! %d\n", status);
            }

            if(tokens[i] == EOL){
                if(status != MATH_STATUS_DONE){
                    printf("didn't get STATUS_DONE afterwards!\n");
                    goto fail;
                }
            }else{
                if(status == MATH_STATUS_DONE){
                    printf("got MATH_STATUS_DONE too early!\n");
                    goto fail;
                }
            }
        }

        math_parser_free(&p);
        return 0;

    fail:
        math_parser_free(&p);
        return 1;
    }
}}:c
