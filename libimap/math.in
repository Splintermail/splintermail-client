{{
    #include <stdio.h>

    typedef union {
        int i;
    } math_val_t;

    typedef struct {
        size_t start;
        size_t end;
    } math_loc_t;

    math_loc_t math_span(math_loc_t loc, math_loc_t token_loc){
        return (math_loc_t){.start = loc.start, .end = token_loc.end};
    }
}}:c

%generator c
%kwarg root line
%destructor i { printf("hi\n"); }

## You don't actually have to declare tokens, unless you want to set types.
# EOL;
NUM:i;
# PLUS;
# MINUS;
# MULT;
# DIV;
# LPAREN;
# RPAREN;

# mult_op = MULT | DIV;
# sum_op = PLUS | MINUS;
# factor = NUM | LPAREN expr RPAREN;
# term = factor *(mult_op factor);
# expr = term *(sum_op term);
# line = < expr > EOL;

mult_op:i =
| MULT {$$=1;}
| DIV {$$=0;}
;

sum_op:i =
| PLUS {$$=1;}
| MINUS {$$=-1;}
;

factor:i =
| NUM:n {$$=$n;}
| LPAREN expr:e RPAREN {$$=$e;}
;

term:i =
    factor:f1 {$$=$f1;}
    *(
        mult_op:m
        factor:f2
        {$$=$$*$f2 if $m else $$/$f2}:py
        {$$=$m ? $$*$f2 : $$/$f2;}:c
    )
;

expr:i =
    term:t1 {$$=$t1;}
    *(
        sum_op:s
        term:t2
        {$$=$$ + $s*$t2;}
    )
;

line =
    <
        expr:e
        { $$ = $e; }:py
        { printf("line=%d\n", $e); }:c
    ?
        { print("bad line") }:py
        { printf("bad line\n"); }:c
    > EOL;

{{
    if __name__ == "__main__":
        tokens = [
            Token(PLUS),
            Token(EOL),
            Token(NUM, 18),
            Token(DIV),
            Token(NUM, 6),
            Token(DIV),
            Token(NUM, 3),
            Token(EOL),
        ]
        p = Parser(repeat=True)
        for t in tokens:
            expr = p.feed(t)
            if expr is not None:
                print(expr.val)
}}:py

{{
    int main(int argc, char **argv){
        call_t calls[100];
        sem_t sems[100];
        size_t callsmax = sizeof(calls) / sizeof(*calls);
        size_t semsmax = sizeof(sems) / sizeof(*sems);
        imf_parser_t p = {
            .callstack = calls,
            .callsmax = callsmax,
            .semstack = sems,
            .semsmax = semsmax,
        };

        int tokens[] = {
            NUM, 18,
            DIV, 0,
            NUM, 6,
            DIV, 0,
            NUM, 3,
            EOL, 0,
        };
        size_t ntokens = sizeof(tokens) / sizeof(*tokens);

        bool ok = false;
        for(size_t i = 0; i < ntokens; i += 2){
            // printf("feeding %s\n", token_name(tokens[i]));
            sem_t sem = {.val.i = tokens[i+1]};
            parse_line(&p, tokens[i], sem, &ok);

            if(tokens[i] == EOL){
                if(!ok){
                    printf("didn't get OK afterwards!\n");
                    return 1;
                }
            }else{
                if(ok){
                    printf("got OK too early!\n");
                    return 1;
                }
            }
        }

        return 0;
    }
}}:c
